---
title: 播放期间的流延迟
description: 播放期间的流延迟
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 0f57eb9820ab0cc2c3ec8e062e87a19f8dde2650
ms.sourcegitcommit: 418e6617e2a695c9cb4b37b5b60e264760858acd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/07/2020
ms.locfileid: "96800615"
---
# <a name="stream-latency-during-playback"></a>播放期间的流延迟


当音频播放流处于运行状态时，WaveRT 端口驱动程序的角色会很小。 如下图所示，在播放期间，WaveRT 端口驱动程序的客户端将其数据写入循环缓冲区，然后音频设备将从缓冲区读取此数据。 此活动不需要来自端口驱动程序的干预。 换句话说，音频数据直接在用户模式应用程序与音频硬件之间流动，无需任何内核模式软件组件接触。

在关系图中，写入和播放位置连续按从左到右的顺序进行，因为音频数据流流经循环缓冲区。 缓冲区被描述为循环，因为当播放位置或写入位置到达缓冲区末尾时，它会自动环绕到缓冲区的开头。

播放期间的流延迟有两个主要源，在下图中指定为 A 和 B。

![说明播放流的延迟的关系图](images/wavert-playback.png)

在前面的关系图中， *写入位置* 就是客户端写入缓冲区的最后一个样本的位置。 *播放位置* 是当前通过扬声器播放音频设备的示例。

直到音频设备播放时，从客户端向缓冲区写入音频采样的时间的延迟只是写入位置与播放位置之间的分离。 此隔离是在关系图) 中标记为 A 和 B (延迟的以下两个源的总和：

**延迟 A**：在音频设备从缓冲区中读取数据后，数据驻留在硬件 "先进先出" (FIFO) 缓冲区中，直到音频设备通过数字到模拟转换器 (DAC) 对数据进行时钟。

**延迟 B**：在客户端将数据写入循环缓冲区后，数据将驻留在缓冲区中，直到音频设备读取数据。

客户端不能控制延迟 A，这完全取决于硬件。 典型的 FIFO 可能会存储足够多的示例，以便将 DAC 送进大约64的样本时钟刻度。 但是，客户端会控制滞后时间 B。使延迟 B 太大会给系统带来不必要的延迟。但是，耗尽音频设备会导致太小的风险。

尽管客户端可以设置计时器以定期激活其缓冲区写入线程，但此方法不会达到最小延迟。 为了进一步降低延迟，客户端可以将设备配置为在每次设备从缓冲区中读取新的播放数据块后生成硬件通知。 在这种情况下，客户端线程由硬件通知而不是计时器激活。

通过让音频设备在每次从缓冲区中读取数据块时通知客户端，客户端可以使延迟小于其他可行的情况。

客户端可以通过将 [**KSPROPERTY \_ RTAUDIO \_ HWLATENCY**](./ksproperty-rtaudio-hwlatency.md) 请求发送到 WaveRT 端口驱动程序来获取导致流式处理延迟的延迟摘要。

客户端确定在写入和播放位置之间保持的隔离量后，客户端会监视播放位置中的更改，以确定如何将写入位置提升。 在 Windows Server 2008 及更高版本的操作系统中，客户端发送 [**KSPROPERTY \_ RTAUDIO \_ POSITIONREGISTER**](./ksproperty-rtaudio-positionregister.md) 属性请求来确定播放位置。 此功能的支持由 PortCls 系统驱动程序中的改进提供。

如果音频设备有一个位置注册，如前面的关系图中所示，则属性请求会将注册映射到用户模式客户端可以访问的虚拟内存地址。 在将位置寄存器映射后，客户端可以读取内存地址的内容，以确定当前的播放位置。

 

