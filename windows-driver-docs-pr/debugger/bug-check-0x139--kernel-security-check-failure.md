---
title: Bug 检查 0x139 KERNEL_SECURITY_CHECK_FAILURE
description: KERNEL_SECURITY_CHECK_FAILURE bug 检查的值为0x00000139。 此 bug 检查指示内核检测到关键数据结构损坏。
keywords:
- Bug 检查 0x139 KERNEL_SECURITY_CHECK_FAILURE
- Bug 检查 0x139 KERNEL_SECURITY_CHECK_FAILURE
ms.date: 01/30/2019
topic_type:
- apiref
api_name:
- Bug Check 0x139 KERNEL_SECURITY_CHECK_FAILURE
api_type:
- NA
ms.localizationpriority: medium
ms.openlocfilehash: 99db1e59fd24b627dc22645ce3357cd02c22b1f3
ms.sourcegitcommit: 418e6617e2a695c9cb4b37b5b60e264760858acd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/07/2020
ms.locfileid: "96824327"
---
# <a name="bug-check-0x139-kernel_security_check_failure"></a>Bug 检查0x139：内核 \_ 安全 \_ 检查 \_ 失败


内核 \_ 安全 \_ 检查 \_ 失败 bug 检查的值为0x00000139。 此 bug 检查指示内核检测到关键数据结构损坏。

> [!IMPORTANT]
> 本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅[蓝屏错误疑难解答](https://www.windows.com/stopcode)。


## <a name="bug-check-0x139-kernel_security_check_failure-parameters"></a>Bug 检查0x139 内核 \_ 安全 \_ 检查 \_ 失败参数


| 参数 | 描述                                                                 |
|-----------|-----------------------------------------------------------------------------|
| 1         | 损坏的类型。 有关详细信息，请参阅下表。      |
| 2         | 引发 bug 检查的异常的捕获帧的地址       |
| 3         | 引发 bug 检查的异常的异常记录的地址 |
| 4         | 预留                                                                    |

 

下表描述了参数1的可能值。

| 参数 1 | 描述                                                                                                                                                                                                                                                                                                       |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0 | 基于堆栈的缓冲区溢出 (旧的/GS 冲突) 。                                                                                                                                                                                                                                                     |
| 1  |  VTGuard 检测代码检测到使用非法虚函数表的尝试。 通常，c + + 对象已损坏，然后尝试使用损坏的对象的 **this** 指针尝试虚拟方法调用。                                                                                     |
| 2  |  堆栈 cookie 检测代码检测到基于堆栈的缓冲区溢出 (/GS 冲突) 。                                                                                                                                                                                                                          |
| 3  |  列表 \_ 项已损坏 (例如，双删除) 。 有关详细信息，请参阅以下原因部分。                                                                                                                                                                                                |
| 4  |  预留                                                                                                                                                                                                                                                                                                          |
| 5  |  传递给认为无效参数无效的函数的参数无效。                                                                                                                                                                                                                            |
| 6  |  加载程序未正确初始化堆栈 cookie 安全 cookie。 这可能是由于构建仅在 Windows 8 上运行的驱动程序并尝试在较早版本的 Windows 上加载驱动程序映像导致的。 若要避免此问题，您必须构建驱动程序，使其在早期版本的 Windows 上运行。 |
| 7  |  请求了严重的程序退出。                                                                                                                                                                                                                                                                               |
| 8  |  编译器插入的数组边界检查检测到非法数组索引操作。                                                                                                                                                                                                                       |
| 9  |  调用 **RtlQueryRegistryValues** 时指定了 rtl \_ query \_ registry \_ DIRECT，而没有 rtl \_ query \_ registry \_ TYPECHECK，目标值不在受信任的系统配置单元中。                                                                                                                             |
|   10 |  间接调用防护检查检测到无效的控制传输。 |
|   11 | 写入保护检查检测到无效的内存写入。 |
|   12 | 尝试切换到无效的纤程上下文。 |
|   13 | 尝试分配无效的寄存器上下文。 |
|   14 | 对象的引用计数无效。 |
|   18 | 尝试切换到无效的 jmp_buf 上下文。 |
|   19 | 对只读数据进行了不安全的修改。 |
|   20 | 加密自检失败。 |
|   21 | 检测到无效的异常链。 |
|   22 | 出现加密库错误。 |
|   23 | 在 DllMain 内进行了无效的调用。 |
|   24 | 检测到无效的映像基址。 |
|   25 | 保护延迟加载导入时遇到不可恢复的错误。 |
|   26 | 调用了不安全的扩展。 |
|   27 | 调用了不推荐使用的服务。 |
|   28 | 检测到界限缓冲区访问。 |
|   29 | RTL_BALANCED_NODE RBTree 项已损坏。 |
|   37 | 调用了超出范围的 switch jumptable 条目。 |
|   38 | 试图 longjmp 的目标无效。 |
|   39 | 导出已取消调用目标不能成为有效的调用目标。 |
 

<a name="cause"></a>原因
-----

使用参数1表和转储文件，可以缩小此类型的许多 bug 检查的原因。

列出 \_ 条目损坏可能难以跟踪，此错误检查指示已引入双向链接列表中的不一致 (在列表中添加或删除单个列表条目元素时检测到该列表) 。 遗憾的是，在发生损坏时不一定会检测到不一致的情况，因此，可能需要某些侦探工作来确定根本原因。

列表项损坏的常见原因包括：

-   驱动程序已损坏内核同步对象，例如 KEVENT (例如，当线程仍在等待同一 KEVENT 时，这种情况下会初始化 KEVENT，或者允许基于堆栈的 KEVENT 在另一个线程使用该 KEVENT) 时超出范围。 此类 bug 检查通常发生在 nt 中！Ke \* 或 nt！Ki \* 代码。 当线程完成等待同步对象或代码尝试将同步对象置于终止状态时，就会发生这种情况。 通常，要发出信号的同步对象是已损坏的对象。 有时，具有特殊池的驱动程序验证程序可以帮助跟踪出现故障的原因， (如果损坏的同步对象在已释放) 的池块中。
-   驱动程序已损坏定期 KTIMER。 此类 bug 检查通常发生在 nt 中！Ke \* 或 nt！Ki \* 代码，涉及到计时器发出信号，或插入或删除计时器表中的计时器。 正在操作的计时器可能是损坏的计时器，但可能需要检查带有 [**！ timer**](-timer.md) (的计时器表，或手动遍历计时器列表链接) 以识别哪个计时器已损坏。 有时，如果损坏的 KTIMER 位于已) 的池块中，则具有特殊池的驱动程序验证程序可以帮助跟踪发生故障的 (原因。
-   驱动程序已 mismanaged 内部列表 \_ 项样式链接的列表。 典型的示例是在同一列表项上调用 **RemoveEntryList** 两次，而不会在两个 **RemoveEntryList** 调用之间重新插入列表项。 可以进行其他变体，例如将条目插入同一列表。
-   驱动程序释放了包含列表项的数据结构 \_ ，但没有从其相应的列表中删除数据结构，从而导致稍后在重复使用旧池块后检查列表时检测到损坏。
-   驱动程序已 \_ 以并发方式使用列表项样式列表，而没有正确的同步，导致列表更新。

在大多数情况下，你可以通过以下方式来确定损坏的数据结构：向前和向后浏览链接列表 ([**dl**](dl--display-linked-list-.md) 和 **dlb** 命令对于此目的非常有用) 并且比较结果。 如果列表在前向和向后遍历之间不一致，通常是损坏的位置。 由于链接列表更新操作可以修改相邻元素的列表链接，因此应密切查看损坏列表项的相邻位置，因为它们可能是底层原因。

由于许多系统组件在内部利用列表 \_ 条目列表，因此使用系统 api 的驱动程序所事务管理不善的各种类型的资源可能会导致系统管理的链接列表中的链接列表损坏。

<a name="resolution"></a>解决方法
----------

确定此问题的原因通常需要使用调试器来收集其他信息。 应该检查多个转储文件，以查看此 stop 代码是否具有类似的特征，例如在出现停止代码时运行的代码。

有关详细信息，请参阅使用[Windows 调试器的故障转储分析 (WinDbg) ](crash-dump-files.md)[使用！分析扩展](using-the--analyze-extension.md)和[！分析](-analyze.md)。

使用事件日志来查看是否存在导致此 stop 代码的更高级别事件。

这些常规疑难解答提示可能会有所帮助。

-   如果最近向系统中添加了硬件，请尝试删除或替换它。 或与制造商联系，查看是否有可用的修补程序。

-   如果最近添加了新的设备驱动程序或系统服务，请尝试删除或更新它们。 尝试确定系统中发生了导致新 bug 检查代码的更改。

-   检查中的系统日志事件查看器是否有其他错误消息，这些错误消息可能有助于找出导致错误的设备或驱动程序。 有关详细信息，请参阅[打开事件查看器](https://support.microsoft.com/hub/4338813/windows-help#1TC=windows-7)。 在系统日志中查找与蓝屏同时出现的严重错误。

-   查看 **设备管理器** 查看是否有任何设备标记为惊叹号 (！ ) 。 查看在驱动程序属性中显示的任何错误驱动程序的事件日志。 请尝试更新相关驱动程序。

-   运行病毒检测程序。 病毒可能会感染为 Windows 格式化的所有类型的硬盘，导致磁盘损坏可能生成系统 bug 检查代码。 请确保病毒检测程序检查主启动记录中是否有病毒感染。

-   有关其他常规疑难解答信息，请参阅 [**蓝屏数据**](blue-screen-data.md)。

## <a name="span-idsee_alsospansee-also"></a><span id="see_also"></span>另请参阅


[使用 Windows 调试器 (WinDbg) 进行故障转储分析](crash-dump-files.md)

[使用 WinDbg 分析内核模式转储文件](analyzing-a-kernel-mode-dump-file-with-windbg.md)

 

 




