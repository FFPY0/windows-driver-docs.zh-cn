---
title: Bug 检查 0x7F UNEXPECTED_KERNEL_MODE_TRAP
description: UNEXPECTED_KERNEL_MODE_TRAP bug 检查的值为0x0000007F。
keywords:
- Bug 检查 0x7F UNEXPECTED_KERNEL_MODE_TRAP
- UNEXPECTED_KERNEL_MODE_TRAP
ms.date: 12/09/2020
topic_type:
- apiref
api_name:
- UNEXPECTED_KERNEL_MODE_TRAP
api_type:
- NA
ms.localizationpriority: medium
ms.openlocfilehash: 1bd4da01a5cb09a57549455d43a0b820094fad22
ms.sourcegitcommit: 11a82f18ee7874537597792cb77f749d5ce6eee5
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/10/2020
ms.locfileid: "96999159"
---
# <a name="bug-check-0x7f-unexpected_kernel_mode_trap"></a>Bug 检查0x7F：意外的 \_ 内核 \_ 模式 \_ 陷阱

意外的 \_ 内核 \_ 模式 \_ 陷阱 bug 检查的值为0x0000007f。 此错误检查表明 Intel CPU 生成了陷阱并且内核未能捕获此陷阱。

此陷阱可以是 *绑定的陷阱* (陷阱：不允许内核捕获) 或 *双重错误* (处理早期错误时出现的错误，这始终导致系统故障) 。

> [!IMPORTANT]
> 本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅[蓝屏错误疑难解答](https://www.windows.com/stopcode)。

## <a name="unexpected_kernel_mode_trap-parameters"></a>意外的 \_ 内核 \_ 模式 \_ 陷阱参数

## <a name="parameter-1"></a>参数 1

蓝屏上出现的第一个参数指定陷阱号。

最常见的陷阱代码包括：

| 参数 | 陷阱代码  | 说明                 |  
|-----------|------------|-----------------------------|
|0x00000000 | 被零除错误| 指示执行了一个 DIV 指令，除数为零。 内存损坏、其他硬件问题或软件故障可能导致此错误。|
|0x00000004 | 溢出           | 当设置) 标志的溢出 (时，当处理器执行对中断处理程序的调用时发生。 |
| 0x00000005| 界限检查错误 | 指示在执行绑定指令时处理器会发现操作数超出了指定的限制。 绑定指令可确保已签名数组索引在特定范围内。 |
|0x00000006 | 无效操作码     | 指示处理器尝试执行无效的指令。 当指令指针损坏并指向错误的位置时，通常会发生此错误。 导致此错误的最常见原因是硬件内存损坏。 |
|0x00000008 | 双重错误       | 指示在调用处理程序之前发生的异常。 通常，这两个异常按顺序处理。 但是，有几个异常不能按顺序进行处理，在这种情况下，处理器会发出两个错误。  双重错误有两个常见的原因：1。 内核堆栈溢出。 当命中保护页，并且内核尝试推送捕获帧时，将发生此溢出。 由于没有剩余的堆栈，导致了堆栈溢出，导致了双重错误。 如果你认为已发生此情况，请使用 [**！ thread**](-thread.md) 来确定堆栈限制，然后使用 [**Kb (显示堆栈 Backtrace)**](k--kb--kc--kd--kp--kp--kv--display-stack-backtrace-.md) 使用大参数 (例如， **kb 100**) 以显示完整堆栈。 2. 另一个常见原因是硬件问题。|

常见的陷阱代码包括：

- 0x00000001--系统调试程序调用

- 0x00000003--调试器断点

- 0x00000007--不存在协处理器的硬件协处理器指令

- 0x0000000A--损坏的任务状态段

- 0x0000000B--访问不存在的内存段

- 0x0000000C-访问超出堆栈限制的内存

- 0x0000000D--未被其他异常覆盖的异常;适用于应用程序的访问冲突的保护错误

对于其他陷阱号，请参阅您正在进行故障排除的处理器的 Intel 处理器体系结构手册。

## <a name="cause"></a>原因

通常，在安装有故障或不匹配的硬件 (特别是内存) 或安装的硬件发生故障后，通常会发生错误检查0x7F。

当内核堆栈溢出时，可能会出现 double 错误。 如果将多个驱动程序附加到同一堆栈，则会发生此溢出。 例如，如果两个文件系统筛选器驱动程序附加到同一堆栈，然后文件系统 recurses 返回，则堆栈溢出。

## <a name="debugging"></a>调试

始终以详细-v 选项的 [**！分析**](-analyze.md) 扩展开头。 检查输出和错误代码。 如果存在多个转储，请查找重复出现的趋势。

如果！分析无法满足要求，请使用 [**kv (显示 Stack Backtrace)**](k--kb--kc--kd--kp--kp--kv--display-stack-backtrace-.md) 调试程序命令。

- 如果 **kv** 显示 **taskGate**，请使用 tss (在冒号前面的部分 [**显示任务状态段)**](-tss--display-task-state-segment-.md) 命令。

- 如果 **kv** 显示捕获帧，请使用 " [**(显示陷印帧)**](-trap--display-trap-frame-.md) 命令设置框架的格式。

- 否则，请使用 (在相应的帧上 [**显示捕获帧)**](-trap--display-trap-frame-.md) 命令。  (在基于 x86 的平台上，此框架与过程 **NT！KiTrap**) 

使用其中一个命令后，再次使用 **kv** 来显示新堆栈。

## <a name="troubleshooting"></a>疑难解答

### <a name="hardware"></a>硬件

如果最近将硬件添加到计算机，请将其删除，查看错误是否重复出现。 如果现有硬件出现故障，请卸下或更换故障部件。 运行系统制造商提供的硬件诊断，以确定哪些硬件组件发生了故障。

错误或不匹配的内存可能导致此错误检查。 使用 Windows 中的内存诊断程序来测试所有系统内存。

确认所有硬盘驱动器、硬盘控制器都与安装的 Windows 版本兼容。

还有可能是系统主板出现问题，如有划痕的跟踪或组件有问题。 电源故障也可能导致问题。

超频 (将 CPU 设置为以额定规范以上的速度运行) 会导致此错误。 如果超频了出现错误的计算机，则将 CPU 恢复为默认时钟速度设置。 如果该选项可用，还可以禁用 BIOS 的内存缓存来尝试解决问题。

### <a name="software"></a>软件

查看事件查看器中的系统日志，以获取可能有助于识别导致错误的设备或驱动程序的其他错误消息。

检查 ACPI/BIOS、硬驱动程序控制器或硬件制造商提供的网络更新的可用性。

如果在安装新的或更新的设备驱动程序之后出现错误，则应删除或替换该驱动程序。 如果在这种情况下，在启动序列过程中发生错误，则可以使用安全模式来重命名或删除有故障的驱动程序。 如果在安全模式下使用驱动程序作为系统启动过程的一部分，则必须通过使用恢复控制台来启动计算机才能访问该文件。 你可能想要尝试 " **最后一次** 正确的配置" 选项。 如果一次仅添加一个驱动程序或服务，则此选项最有效。

如果在升级到新版本的 Windows 操作系统时遇到此错误，则此错误可能是由于设备驱动程序、系统服务、病毒扫描程序或与新版本不兼容的备份工具导致的。 如果可能，请删除所有第三方设备驱动程序和系统服务，并在升级之前禁用任何病毒扫描程序。 请与软件制造商联系以获取这些工具的更新。 此外，请确保已安装最新的 Windows 更新。

## <a name="see-also"></a>另请参阅

[！分析](-analyze.md)

[Bug 检查代码参考](bug-check-code-reference2.md)
