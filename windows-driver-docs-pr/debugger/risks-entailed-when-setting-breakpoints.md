---
title: 设置断点造成的风险
description: 设置断点造成的风险
keywords:
- 断点、风险
ms.date: 05/23/2017
ms.localizationpriority: medium
ms.openlocfilehash: f2cf85bd6b8e276f4e544b283237b541f3933971
ms.sourcegitcommit: 418e6617e2a695c9cb4b37b5b60e264760858acd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/07/2020
ms.locfileid: "96825191"
---
# <a name="risks-entailed-when-setting-breakpoints"></a>设置断点造成的风险


通过指定内存地址或符号加上偏移量来设置 [断点](using-breakpoints.md) 时，不得将此断点放在指令的中间。

例如，请考虑下面的反汇编代码。

```dbgcmd
770000f1 5e               pop     esi
770000f2 5b               pop     ebx
770000f3 c9               leave
770000f4 c21000           ret     0x10
770000f7 837ddc00         cmp     dword ptr [ebp-0x24],0x0
```

前三个指令的长度仅为一个字节。 但是，第四个指令的长度为三个字节。  (包括字节0x770000F4、0x770000F5 和 0x770000F6 ) 。如果要使用 **bp**、 **bu** 或 **ba** 命令在此指令上放置断点，则必须指定0x770000F4 地址。

如果使用 **ba** 命令在0x770000F5 地址中放置断点，则处理器会在该位置放置一个断点。 但永远不会触发此断点，因为处理器将0x770000F4 视为指令的实际地址。

如果使用 **bp** 或 **Bu** 命令在0x770000F5 地址中放置断点，调试器将在该位置写入一个断点。 但由于调试器创建断点的方式，此断点可能会损坏目标：

1.  调试器保存0x770000F5 的内容，并使用断点指令覆盖此内存。

2.  如果尝试在调试器中显示此内存，调试器将不会显示已写入的断点说明。 调试器将显示 "应该" 存在的内存。 也就是说，调试器会显示原始内存，或对自插入断点以来所做的任何修改。

3.  如果使用 **BC** 命令删除断点，则调试器会将原始内存还原到正确的位置。

在0x770000F5 中放置断点时，调试器将保存此字节，并在此处写入一个中断指令。 但是，当应用程序运行时，它将达到0x770000F4 地址，并将此地址识别为多字节指令的第一个字节。 然后，处理器会尝试将0x770000F4、0x770000F5 和其他一些字节合并为一个指令。 这种组合可创建各种行为，无需任何这种行为。

因此，当你使用 **bp**、 **bu** 或 **ba** 命令放置断点时，请确保始终将断点置于正确的地址。 如果你使用 WinDbg 图形界面来添加断点，则无需考虑这种情况，因为会自动选择正确的地址。

 

 





