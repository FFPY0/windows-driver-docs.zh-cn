---
title: 支持内存库中的帧缓冲区
description: 支持内存库中的帧缓冲区
keywords:
- 显示驱动程序 WDK Windows 2000，存款帧缓冲区
- 存款帧缓冲 WDK Windows 2000 显示
- 帧缓冲区 WDK Windows 2000 显示
- 存款 memory WDK Windows 2000 显示
- 存款回调 WDK Windows 2000 显示
- 银行 WDK Windows 2000 显示器
- 将视频内存映射到存款帧缓冲区
- 跨多个银行
- 帧缓冲区中的多个银行 WDK Windows 2000 显示
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 4eba922339529bb2bfe8d1562f15a07e76c5e116
ms.sourcegitcommit: 418e6617e2a695c9cb4b37b5b60e264760858acd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/07/2020
ms.locfileid: "96830053"
---
# <a name="supporting-banked-frame-buffers"></a>支持内存库中的帧缓冲区


## <span id="ddk_supporting_banked_frame_buffers_gg"></span><span id="DDK_SUPPORTING_BANKED_FRAME_BUFFERS_GG"></span>


如今的大多数加速器都具有可线性映射到 CPU 地址空间的 *帧缓冲区* 。 此类设备的显示驱动程序无需支持存款帧缓冲区。

GDI 无法直接访问与存款帧缓冲区关联的 *存款内存* 。 因此，具有此类帧缓冲区的设备的显示驱动程序必须将帧缓冲区分为一系列连续的块，并为 GDI 提供一种将其绘制操作执行到相应的帧缓冲区库的方法。 也就是说，在根据需要将数据移至后续银行之前，会将数据写入帧缓冲区的一个 bank，以通过一种称为 " *存款回叫*" 的机制完成绘制操作。

*Permedia* 示例显示了驱动程序开发工具包随附的驱动程序 (DDK) 提供实现存款帧缓存支持的示例代码。

**注意**   Microsoft Windows 驱动程序工具包 (WDK) 不包含 3Dlabs Permedia2 (*3dlabs.htm*) 和 3Dlabs *Permedia3 (Perm3.htm) 示例* 显示驱动程序。 你可以从 Windows Server 2003 SP1 DDK 获取这些示例驱动程序，你可以从 WDHC 网站的 "DDK-Windows 驱动程序开发工具包" 页下载该驱动程序。

 

下图显示了一个示例加速器的帧缓冲区（1024-768 VGA 显示缓冲区），分为多个 bank。 此图仅用于说明目的。 显示驱动程序并未专门使用物理地址 A000，而是使用由微型端口驱动程序传递给它的逻辑地址。

![说明将视频内存映射到存款帧缓冲区的关系图](images/banking1.png)

在此示例中，通过一系列用于处理帧缓冲区中的相邻银行的绘图操作将视频内存内容写入加速。 就 GDI 而言，其每个绘制操作都看起来是标准帧缓冲区，而不是加速器帧缓冲区的不同银行。 加速器的设备驱动程序处理的是银行操作，这些操作导致 GDI 按银行向加速器的帧缓冲区绘制。

当加速器使用一个存款帧缓冲区时，框架缓冲区是 *设备管理的图面* ，因此显示驱动程序会挂钩绘图函数调用。 当显示驱动程序挂接调用（如绘图路径、填充路径或 *位块传输*）时，它将确定帧缓冲区中的哪些银行受调用的 draw 函数的影响。

如果驱动程序所强调的是使 GDI 执行绘制功能，则驱动程序将调用相应的 **Eng**_Xxx_ 函数。 但是，在进行调用之前，显示驱动程序必须修改在挂钩调用中收到的剪辑和 surface 对象，并将回拨中已修改的对象传递给 GDI。 修改剪辑和表面对象，以防止在银行范围之外绘制 GDI。 也就是说，如果调用 GDI 来绘制一个部分在下一个 bank 中的路径，并且如果不修改剪辑和 surface 对象，则 GDI 将写入到超出当前 bank 范围的内存。 如果 GDI 尝试在银行范围外绘制，则产生的访问冲突可能很难跟踪。

下图中的示例的 "存款帧缓冲区" 显示了在显示屏上绘制的椭圆形对象如何跨越两个银行的存款帧缓冲区： BANK \_ 1 和 bank \_ 2。

![说明帧缓冲区中跨多个银行的绘图对象的关系图](images/pvscan0.png)

若要绘制此对象，GDI 必须首先将 BANK 1) 中 (椭圆的顶部绘制 \_ 到标准帧缓冲区，然后将该椭圆的下半部分绘制到相同的标准缓冲区。 然后，显示驱动程序必须将这两个后续写入（GDI）映射到要 \_ \_ 显示的 "存款帧缓冲区" 的 bank 1 和 bank 2，还可以防止 gdi 写入超出每个银行的限制。

执行存款帧缓冲时，显示驱动程序可以通过检查调用的参数或通过回调到 GDI 来确定对象的边界 (目标矩形的大小) 。 从对象的边界，驱动程序可以确定对象跨越了多少个银行。 对于边框触及的每个单元，显示驱动程序会回拨到适当的 GDI draw 函数，从而更改每个调用的值。

驱动程序将最初由 GDI 传递的 [**CLIPOBJ**](/windows/win32/api/winddi/ns-winddi-clipobj) 成员更改为与银行边界中的更改相对应。 重新定义了前和下一个扫描值，以便 GDI 不会尝试在银行的限制之外进行绘制。 银行经理获取从 GDI 获取的原始 CLIPOBJ 数据，并保留值以便以后还原。 然后，它将更改边界以提供新的 **rclBounds** 和 **rclBounds** 值，这些值描述要绘制到的银行的范围。 在银行期间，GDI 必须对大小执行剪裁，以防止绘制整个路径并覆盖当前银行的限制。

如果由 GDI 传递的原始 CLIPOBJ 定义为 **NULL** 或 DC \_ 普通，则显示驱动程序将传递通过 [**ENGCREATECLIP**](/windows/win32/api/winddi/nf-winddi-engcreateclip)创建的替换 CLIPOBJ。 此替换 CLIPOBJ 将被修改以定义 *剪辑窗口* ，使 GDI 可以剪裁到单个银行的范围。 如果 CLIPOBJ 非常复杂，如上图中所示，椭圆上的一个三角形剪辑对象，则显示驱动程序将使用 **rclBounds** 和 **rclBounds** 值修改复杂的 CLIPOBJ，以在两个剪辑对象之间产生累加效果。 因此，禁止 GDI 写入银行的末尾。 驱动程序还必须还原以前从 GDI 中获取的 CLIPOBJ 数据的原始界限。

除了更改边界值以外，显示驱动程序还 \_ \_ 会在 [**CLIP 对象**](/windows/win32/api/winddi/ns-winddi-clipobj) 中设置 OC BANK 剪辑标志，以通知 GDI 这是一个 *存款回叫 * *。*

还必须创建 GDI，使其引用标准帧缓冲区的开头。 调用以绘制时，GDI 只是获取指向 SURFOBJ 的指针，其中包括 **pvScan0**、 **lDelta** 和 **iBitmapFormat** 成员。 GDI 使用以下值计算在图面上绘制的位置：

```cpp
start_draw_point = pvScan0 + (y*lDelta) + (x*PixelSize(iBitmapFormat))
```

其中， *x* 和 *y* 是要开始绘制的坐标，而 " *开始 \_ 绘制 \_ 点* " 是要绘制第一个像素的地址的地址。 GDI 对每个绘图调用都执行此计算，并且始终引用 **pvScan0** 的 SURFOBJ，这是标准帧缓冲区开头的逻辑地址。

例如，如果 GDI 需要绘制每像素8位/像素64K 帧缓冲区的全部内容，从 **pvScan0** = 0x100000 的逻辑地址开始，它将结束 0x10FFFF (0x100000 + (63 \* 1024) + (1023) # A5，其中 *y* 为63， **lDelta** 为1024， *x* 为 1023 (上一扫描行中最后一个像素的位置) 。

下一次显示驱动程序调用 GDI 来绘制位于存款帧缓冲区 *下一个* bank 内的对象的一部分时，GDI 会将 *y* 的值解释为64。 如果0x100000 的值为 **pvScan0** ，64为 *y*，则 GDI 将尝试在0x110000 开始写入数据。 但是，0x110000 超出64K 帧缓冲区的0x10FFFF 范围，在此操作过程中，不能由 GDI 写入。

因此，当显示驱动程序请求 GDI 来写入要出现在帧缓存器的第二个和后续 bank 中的数据时，驱动程序必须减小 **pvScan0** 的值，以便 GDI 计算仍引用0x100000 的示例地址的起点。 在此示例中继续，这意味着在绘制到帧缓冲区的第二个堆时，将 **pvScan0** 的值递减为0x090000 的值。 由于此对 **pvScan0** 的更改，GDI 仍将使用对地址0x100000 的引用进行绘制。 也就是说，0x090000 + (64 \* 1024) + 0 等于0x100000，在这种情况下，GDI 必须开始绘制，以便将数据映射到帧缓冲区的第二个组。

