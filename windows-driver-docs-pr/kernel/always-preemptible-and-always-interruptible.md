---
title: 始终可抢占且始终可中断
description: 始终可抢占且始终可中断
keywords:
- preemptible 设计 WDK 内核
- 中断设计 WDK 内核
- 中断请求级别 WDK 内核
- IRQL 级别 WDK 内核
- 变量优先级属性 WDK 内核
- 优先级标准 WDK 内核
- 硬件优先级 WDK 内核
- 更高的 IRQL 级别 WDK 内核
- 低 IRQL 级别 WDK 内核
- PASSIVE_LEVEL WDK
- APC_LEVEL WDK
- DISPATCH_LEVEL WDK
- WAKE_LEVEL WDK
- 延迟的过程调用 WDK 内核
- Dpc WDK 内核
- 任意线程上下文 WDK 内核
- 线程抢占 WDK 内核
- 线程优先级 WDK 内核
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: fe5d0643a96604a4ed3cbd4ef28520614dc6f5a9
ms.sourcegitcommit: 418e6617e2a695c9cb4b37b5b60e264760858acd
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/07/2020
ms.locfileid: "96789811"
---
# <a name="always-preemptible-and-always-interruptible"></a>始终可抢占且始终可中断





Preemptible、可中断的操作系统设计的目标是最大程度地提高系统性能。 任何线程都可由具有较高优先级的线程抢占，并且任何驱动程序的中断服务例程 (ISR) 可能会被以更高中断请求级别运行的例程中断 (IRQL) 。

内核组件根据以下优先级标准之一确定代码序列的运行时间：

-   线程的内核定义的运行时优先级方案。

    系统中的每个线程都具有关联的优先级属性。 通常，大多数线程具有 *可变* 优先级特性：它们始终是 preemptible 的，并且计划使用当前处于同一优先级别的所有其他线程运行轮循机制。 某些线程具有 *实时* 优先级特性：这些时间关键线程将运行到完成，除非它们被具有更高实时优先级特性的线程抢占。 Microsoft Windows 体系结构不提供本身的实时系统。

    无论其优先级特性如何，在硬件中断和某些类型的软件中断发生时，系统中的任何线程都可以被抢占。

-   内核定义的 *中断请求级别* (IRQL) 在给定平台上分配特定中断向量。

    内核将设置硬件和软件中断的优先级，以便某些内核模式代码（包括大多数驱动程序）在更高的 IRQLs 上运行，从而使其计划优先级比系统中的其他线程更高。 一段内核模式驱动程序代码执行的特定 IRQL 由其基础设备的 *硬件优先级* 决定。

    内核模式代码始终是可中断的：任何时候都可能会出现具有较高 IRQL 值的中断，从而导致在该处理器上立即运行系统分配的 IRQL 较高的另一段内核模式代码。 但是，当一段代码在给定的 IRQL 下运行时，内核会在处理器上屏蔽具有较小或等于 IRQL 值的所有中断向量。

最小的 IRQL 级别称为被动 \_ 级别。 在此级别，不会屏蔽中断矢量。 通常以 IRQL = 被动级别运行的线程 \_ 。 下一个更高的 IRQL 级别适用于软件中断。 这些级别包括 APC \_ 级别、调度 \_ 级别或用于内核调试的唤醒 \_ 级别。 设备中断的 IRQL 值仍然更高。 内核保留系统关键中断的最高 IRQL 值，例如系统时钟或总线错误中的值。

某些系统支持例程会以 IRQL = 被动 \_ 级别运行，这可能是因为它们作为可分页代码实现或访问可分页数据，或因为某些内核模式组件设置自己的线程。

同样，一些 [标准的驱动程序例程](./introduction-to-standard-driver-routines.md) 通常以 IRQL = 被动 \_ 级别运行。 但是，多个标准驱动程序例程以 IRQL = 调度 \_ 级别运行，或者对于最低级别的驱动程序，在设备 IRQL (也称为 *DIRQL*) 。 有关 IRQLs 的详细信息，请参阅 [管理硬件优先级](managing-hardware-priorities.md)。

驱动程序中的每个例程都会被中断。 这包括以比被动级别更高的 IRQL 运行的任何例程 \_ 。 仅当该例程正在运行时，如果没有任何中断的情况发生，则在特定 IRQL 上运行的任何例程都将保留对处理器的控制。

与一些较旧的个人计算机操作系统中的驱动程序不同的是，Microsoft Windows 驱动程序的 ISR 绝不会是执行大部分驱动程序 i/o 处理的大型复杂例程。 这是因为任何驱动程序的 *中断服务例程* (ISR) 可能会被另一个例行 (中断，例如，另一个驱动程序的 ISR) 将以更高的 IRQL 运行。 因此，驱动程序的 ISR 不一定会在从其执行路径开始到末尾时不间断地保持对 CPU 的控制。

在 Windows 驱动程序中，ISR 通常会保存硬件状态信息、将 *延迟的过程调用* 排队 (DPC) ，然后迅速退出。 稍后，系统取消排队驱动程序的 DPC，以便驱动程序可以)  (调度级别以较低的 IRQL 完成 i/o 操作 \_ 。 为了获得良好的整体系统性能，在高 IRQLs 运行的所有例程必须快速放弃 CPU 的控制。

在 Windows 中，所有线程都具有线程上下文。 此上下文包含标识拥有线程的进程的信息，以及其他特性（如线程的访问权限）。

一般情况下，只会在请求驱动程序的当前 i/o 操作的线程的上下文中调用一个最高级别的驱动程序。 中间级别或最低级别的驱动程序永远不会假定它在请求其当前 i/o 操作的线程的上下文中执行。

因此，在调用标准驱动程序例程时，驱动程序例程通常会在 *任意线程上下文* 中执行，即任何线程的上下文都是最新的。 出于性能方面的考虑， (避免上下文切换) ，很少有驱动程序设置自己的线程。

 

